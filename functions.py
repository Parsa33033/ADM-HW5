# -*- coding: utf-8 -*-
"""functions

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Jd9CsK3zqm4FBWSyJAJO4CtiZG8oRwnM
"""

#########################################################
############# IMPORT SOME USEFUL LIBRARY ################
#########################################################

import numpy as np
import pandas as pd
from tqdm import tqdm
import pickle as pkl
from time import time, mktime
import traceback
import sys
import os
from collections import OrderedDict
import csv
import datetime
import ast
import gc
from queue import PriorityQueue
import copy
from collections import deque
import networkx as nx
import matplotlib.pyplot as plt
import seaborn as sns
import random



############################################
############# DATA COLLECTION ##############
############################################


class Graph():
    a2q = 'a2q'
    c2a = 'c2a'
    c2q = 'c2q'
    u = 'u'
    v = 'v'
    w = 'w'
    g = 'graph'
    timestamp = 'timestamp'
    _timestamp_csv = 'timestamp.csv'
    _a2q_filename = "sx-stackoverflow-a2q.txt"
    _c2a_filename = "sx-stackoverflow-c2a.txt"
    _c2q_filename = "sx-stackoverflow-c2q.txt"
    _my_graph = 'my_graph.pkl'
    def __init__(self):
        self.timestamp_file = None
        self.graph_info = dict()
    def _initialize(self, graph):
        self.adj_list = dict()
        if graph == Graph.a2q:
            self.filename = self._a2q_filename
            self.pkl = "a2q.pkl"
        elif graph == Graph.c2a:
            self.filename = self._c2a_filename
            self.pkl = "c2a.pkl"
        elif graph == Graph.c2q:
            self.filename = self._c2q_filename
            self.pkl = "c2q.pkl"
    def _get_graph_from_text(self):
        with open(self.filename, 'r') as file:
            graph_list = file.readlines()
            for i in tqdm(graph_list):
                l = list(map(int,i.split()))
                u, v, t = l[0], l[1], l[2]
                if v not in self.adj_list:
                    self.adj_list[v] = []
                if u in self.adj_list:
                    self.adj_list[u].append([v,t])
                else:
                    self.adj_list[u] = []
                    self.adj_list[u].append([v,t])
        self._dump_graph()
    def _dump_graph(self):
        with open(self.pkl, 'wb') as pkl_file:
            pkl.dump(self.adj_list, pkl_file)
    def get_graph(self, graph):
        t1 = time()
        self.graph = graph
        print("Starting to fetch {} graph adjacency list...".format(graph))
        self._initialize(graph)
        if not self.adj_list:
            try:
                with open(self.pkl, 'rb') as pkl_file:
                    self.adj_list = pkl.load(pkl_file)        
            except:
                self._get_graph_from_text()
        print("Fetched {} graph in {:.2f} seconds".format(self.graph, time() - t1))
        return self.adj_list
    def releave_graph(self):
        del self.adj_list
        gc.collect()
    def make_graph(self, timespan):
        r = self.timestamp_file.readlines()
        self.my_graph = dict()
        t1, t2 = timespan
        flag = True
        print("Creating graph!")
        for i in tqdm(r):
            if flag:
                flag = False
                continue
            l = i.split(",")
            t, u, v, w = int(l[0]), int(l[1]), int(l[2]), float(l[3])
            if t1 <= t <= t2:
                if v not in self.my_graph.keys():
                    self.my_graph[v] = []
                if u in self.my_graph.keys():
                    has_edge = False
                    for ii in range(len(self.my_graph[u])):
                        if self.my_graph[u][ii][0] == v:
                            self.my_graph[u][ii][1] += w
                            has_edge = True
                    if not has_edge:
                        self.my_graph[u].append([v,w])
                else:
                    self.my_graph[u] = []
                    self.my_graph[u].append([v,w])
        del r
        del self.timestamp_file
        gc.collect()
        
        with open(self._my_graph, 'wb') as file:
            pkl.dump(self.my_graph, file)
    def get_timestamp(self,timespan):
        self.timestamp_file = open(self._timestamp_csv, 'r')
        self.make_graph(timespan)
    def create_graph(self, graphs, timespan):
        d1, d2 = timespan[0], timespan[1]
        t1 = int(mktime(datetime.datetime.strptime(d1, "%d/%m/%Y").timetuple()))
        t2 = int(mktime(datetime.datetime.strptime(d2, "%d/%m/%Y").timetuple()))
        timespan = (t1, t2)
        if os.path.isfile(self._timestamp_csv):
            t1 = time()
            print("Fetching {}...".format(self._timestamp_csv))
            self.get_timestamp(timespan)
            print("Fetched in {:.2f} seconds.".format(time()-t1))
        else:
            timestamp_dict = dict()
            with open(self._timestamp_csv, 'w', newline='') as timestamp_file:
                writer = csv.writer(timestamp_file)
                writer.writerow([self.timestamp, self.u, self.v, self.w, self.g])
                for graph in graphs:
                    if graph == self.a2q:
                        w = np.e**3
                        filename = self._a2q_filename
                    elif graph == self.c2q:
                        w = np.e**2
                        filename = self._c2q_filename
                    elif graph == self.c2a:
                        w = np.e
                        filename = self._c2a_filename
                    print("Converting graph {} to timestamp dictionary with w={} ...".format(graph, str(w)) )
                    with open(filename, 'r') as file:
                        graph_list = file.readlines()
                        for i in tqdm(graph_list):
                            l = list(map(int,i.split()))
                            u, v, t = l[0], l[1], l[2]
                            writer.writerow([t,u,v,w,graph])
                        del graph_list
                        gc.collect()
            print("Done!!!")
            gc.collect()
            self.get_timestamp(timespan)






#########################################################
#################### FUNCTIONALITY 1 ####################
#########################################################

def func1(graph: Graph, graph_name: str, threshold = 0.2):
    """
    test_function does blah blah blah.
    
    :param graph: instantialized Graph object
    :param graph_name: name of the graph among Graph.a2q, Graph.c2q, and Graph c2a
    :param threshold: threshold of the sparseness of the graph (must be lower than 0.5)
    :return: a list -> [Whether the graph is directed or not, Number of users, Number of answers/comments,
                Average number of links per user, Density degree of the graph,
                Whether the graph is sparse, Whether the graph is dense]
    """ 
    graph.get_graph(graph_name)
    is_directed = False;
    keys = graph.adj_list.keys()
    vertex_num = len(keys)
    degree = 0
    links_per_users_num = 0
    density_degree = 0
    is_sparse = 0
    is_dense = 0
    density = []
    for key in tqdm(keys):
        val = graph.adj_list[key]
        density.append(len(graph.adj_list[key]))
        
        if len(val)>=1:
            val = np.array(val)[:,0]
            degree += len(val)
            if not is_directed:
                for v in val:
                    if v in graph.adj_list.keys():
                        val_v = graph.adj_list[v]
                        if len(val_v)>=1:
                            val_v = set(np.array(graph.adj_list[v])[:,0].flatten())
                            if key in val_v:
                                continue;
                            else:
                                is_directed = True
                                break
    links_per_users_num = degree / vertex_num
    clique_num = (vertex_num * (vertex_num - 1)) / 2
    density_degree = (degree // 2) / clique_num
    if density_degree >= (1-threshold) * clique_num:
        is_dense = 1
    elif density_degree <= threshold * clique_num:
        is_sparse = 1
    graph.releave_graph()
    return [is_directed, vertex_num, degree, links_per_users_num, density_degree, is_sparse, is_dense, density]


#########################################################
#################### FUNCTIONALITY 4 ####################
#########################################################

class MinCut:
    def __init__(self, graph):
        self.graph = copy.deepcopy(graph) 
        self.main_graph = copy.deepcopy(graph)

    def bfs(self, s, t, parent):
        visited = dict(zip(self.graph.keys(), [False] * len(self.graph.keys())))

        queue = []
        queue.append(s)
        visited[s] = True

        while queue:
            u = queue.pop(0)
            for ind, val in self.graph[u]:
                if ind in visited and visited[ind] == False and val > 0:
                    queue.append(ind)
                    visited[ind] = True
                    parent[ind] = u
        return True if visited[t] else False

    def dfs(self, graph, s, visited):
        visited[s] = True
        for i in graph.keys():
            flag = False
            for j in graph[s]:
                if j[0] == i and j[1] > 0:
                    flag = True
                    break
            if flag and not visited[i]:
                self.dfs(graph, i, visited)
    def minCut(self, source, sink):
        parent = dict(zip(self.graph.keys(), [-1] * len(self.graph.keys())))
        max_flow = 0

        while self.bfs(source, sink, parent):
            path_flow = float("Inf")
            s = sink
            while (s != source):
                for i in self.graph[parent[s]]:
                    if i[0] == s:
                        path_flow = min(path_flow, i[1])
                        break
                s = parent[s]
            max_flow += path_flow
            v = sink
            while (v != source):
                u = parent[v]
                for i in range(len(self.graph[u])):
                    if self.graph[u][i][0] == v:
                        self.graph[u][i][1] -= path_flow
                        break
                for i in range(len(self.graph[v])):
                    if self.graph[v][i][0] == u:
                        self.graph[v][i][1] += path_flow
                        break
                v = parent[v]

        visited = dict(zip(self.graph.keys(), [False] * len(self.graph.keys())))
        self.dfs(self.graph, s, visited)
        l = []
        for i in self.graph.keys():
            for j in self.graph[i]:
                for k in self.main_graph[i]:
                    if j[0] == k[0] and j[1] == 0 and k[1] > 0 and visited[i]:
                        l.append([i, j[0]])
        return l


#########################################################
#################### VISUALIZATION 1 ####################
#########################################################

def choose_the_graph():

  ''' This function allow to the user to choose the type of graph of which he wants 
  to see overall features. '''

  graph_type = input('Choose a graph: \nA: Graph with answers to questions \nB: Graph with comments to questions \nC: Graph with comments to answers\n')
  if graph_type == 'A':
    choose_graph, gr = Graph.a2q, 'answers to questions'
  elif graph_type == 'B':
    choose_graph, gr = Graph.c2q, 'comments to questions'
  elif graph_type == 'C':
    choose_graph, gr = Graph.c2a, 'comments to answers'
  return(choose_graph, gr)

def visualization1(g):

  '''This function returns a table which contains some important features that characterize a graph.
   The graph which we are dealing with is chosen by the user.
   Moreover this fucntion plot the distribution of nodes' degree (outer degree) 
   in the chosen graph'''

  choose_graph, gr = choose_the_graph()

  # call the function of the first functionality to get some summaries of the chosen graph
  is_directed, vertex_num, degree, links_per_users_num, density_degree, is_sparse, is_dense, distr_degree = func1(g, choose_graph)
  # modify some output for the visualization 
  if is_directed:
    directed = "It's directed!"
  else:
    directed = "It's undirected!"
  if is_sparse == 1:
    sparse = "It's sparse!"
  else:
    sparse = "It's dense!"
  links_per_users_num = round(links_per_users_num,3)
  density_degree = round(density_degree,5)

  # print the table 
  print('\n\nGraph with '+gr)
  d = {'Summary': [directed,vertex_num,degree,links_per_users_num,density_degree,sparse]}
  df = pd.DataFrame(data=d, index = ["Directed or Undirected?","Number users",
                                     "Number of comments/answers","Average degree",
                                     "Density degree","Sparse or Dense?"])
  
  print(df)

  # plot the distribution of degrees in the network
  plt.figure(figsize = (13,8))
  sns.set(style="darkgrid")
  sns.distplot(distr_degree)
  plt.title('Distribution of degree in the graph '+gr, fontsize = 17)
  plt.show()



#########################################################
#################### FUNCTIONALITY 2 ####################
#########################################################

def dijkstra(graph: dict, u_init: int):
    nodes = graph.keys()
    path_w = dict(zip(nodes, [float('inf')] * len(nodes)))
    path_visited = dict(zip(nodes, [-1] * len(nodes)))
    path_w[u_init] = 0
    
    unvisited = [u for u in nodes]
    while len(unvisited) > 0:
#         if len(unvisited) % 1000 == 0:
#             print(len(unvisited))
        choices = {v: path_w[v] for v in unvisited}
        u = min(choices, key=choices.get)
        unvisited.remove(u)
        for v, w in graph[u]:
            if path_w[v] > path_w[u] + 1/w:
                path_visited[v] = u
            path_w[v] = min(path_w[v], path_w[u] + 1/w)
    return path_w, path_visited


class Metric():
    betweenness = "Betweenness"
    pagerank = "PageRank"
    closeness_cent = "ClosenessCentrality"
    degree_cent = "DegreeCentrality"
    def compute_betweeness(self, graph: dict):
        CB = dict(zip(graph.keys(), [0] * len(graph.keys())))
        for s, weight in tqdm(graph.items(), total=len(graph)):
            S = deque() #stack
            P = dict(zip(graph.keys(), [[]] * len(graph.keys())))
            ro = dict(zip(graph.keys(), [0] * len(graph.keys())))
            ro[s] = 1
            d = dict(zip(graph.keys(), [-1] * len(graph.keys())))
            ro[s] = 0
            Q = deque() # queue
            Q.append(s)
            while Q:
                v = Q.popleft()
                S.append(v)
                for w, w_weight in graph[v]:
                    if d[w] < 0:
                        Q.append(w)
                        d[w] = d[v] + 1
                    if d[w] == d[v] + 1:
                        ro[w] += ro[v]
                        P[w].append(v)
            delta = dict(zip(graph.keys(), [0] * len(graph.keys())))
            while S:
                w = S.pop()
                for v in P[w]:
                    if ro[w] != 0:
                        delta[v] += (ro[v]/ro[w]) * (1 + delta[w])
                if w != s:
                    CB[w] += delta[w]
        return CB
    def compute_closeness(self, graph: dict, u: int):
        path_distance, _ = dijkstra(graph, u)
        sum_weight = 0
        for k in path_distance.keys():
            if path_distance[k] != float('inf'):
                sum_weight += path_distance[k]
        return len(path_distance.keys())/sum_weight
    def compute_degree_centrality(self, graph: dict, u: int):
        d = len(graph[u])
        for k in graph.keys():
            if k != u:
                for v, k in graph[k]:
                    if v == u:
                        d += 1
        return d
    def compute_page_rank(self, graph: dict):
        self.pr = dict()
        keys = graph.keys()
        n = len(keys)
        r_default = 1/n
        for key in tqdm(keys):
            val = graph[key]
            if len(val) >= 1:
                val = np.array(val)[:,0]
                out_degree = len(val)
                if key not in self.pr.keys():
                    self.pr[key] = [r_default, out_degree, []]
                for v in val:
                    if v in self.pr.keys():
                        self.pr[v][2].append(key)
                    else:
                        out_degree_v = len(graph[v])
                        self.pr[v] = [r_default, out_degree_v, [key]]     
        epsilon = 0.000000001
        beta = 0.2
        while True:
            d = dict()
            for vertex in self.pr.keys():
                u = self.pr[vertex]
                r_prev = u[0]
                in_degrees = u[2]
                r = 0
                for v in in_degrees:
                    r += beta * (self.pr[v][0]/self.pr[v][1])
                r += (1 - beta)/n
                self.pr[vertex][0] = r
                cond = abs(r - r_prev)
                d[vertex] = cond
                if cond <= epsilon:
                    break
            a = np.array(list(d.values()))
            if len(a[a > epsilon]) == 0:
                break;


def func2(graph: dict, metric: Metric, node: int, metric_type):
    """
    test_function does blah blah blah.
    
    :param graph: instantialized Graph object
    :param metric: instantiated metric object
    :param node: The node that the func2 is going to be applied to
    :param metric_type: the type of the metric wanted [Metric.pagerank, Metric.betweenness, Metric.closeness_cent, Metric.degree_cent]
    :return: a list -> [Whether the graph is directed or not, Number of users, Number of answers/comments,
                Average number of links per user, Density degree of the graph,
                Whether the graph is sparse, Whether the graph is dense]
    """ 
    if metric_type == Metric.pagerank:
        metric.compute_page_rank(graph)
        return metric.pr[node][0]
    elif metric_type == Metric.betweenness:
        return metric.compute_betweeness(graph)[node]
    elif metric_type == Metric.closeness_cent:
        return metric.compute_closeness(graph, node)
    elif metric_type == Metric.degree_cent:
        return metric.compute_degree_centrality(graph, node)


  
#########################################################
#################### VISUALIZATION 2 ####################
#########################################################

def create_my_graph(g):

  ''' 
  Input g: a dictionary that represensts a graph. 
  
  
  This function returns a network x directed graph which contains all weighted edges
  that are colleced in g. '''

  # create a graph with networkx library
  myG = nx.DiGraph()

  # add edges to the graph 
  for u in list(g.keys()):
    for v in g[u]:
      if u != v:
        myG.add_edge(u, v[0], weight=v[1])
        
  return myG

def create_my_subgraph(g, input_node):

  ''' Given a node, this fucntion return a subgraph of g that contains the input node
  and its first level neighbors. '''


  # create a graph 
  myG = create_my_graph(g)

  # select the neighbors of an input node
  node_neighbors = [input_node]
  neighbors = g[input_node]
  for node in neighbors:
    node_neighbors.append(node[0])
  
  # create the subgraph with networkx
  subG = myG.subgraph(node_neighbors)  

  return(subG)



def plot_subgraph(g, chosen_node, m_name, value_metric):

  ''' This function creates a plot of a netowork with shows a subgraph of the graph g 
  which is obtained with the previous fucntion. '''


  # create the sub graph
  subG = create_my_subgraph(g, input_node = chosen_node)
  
  # plot the graph
  plt.figure(figsize=(20,10))
  
  # classify the edges based on the weight that they have: 
  # small: 'Comment to answer'
  # medium: 'Comment to question'
  # large: 'Answer to question'

  elarge = [(u, v) for (u, v, d) in subG.edges(data=True) if u != v and d["weight"] == np.e**3]
  emedium = [(u, v) for (u, v, d) in subG.edges(data=True) if  u != v and d["weight"] == np.e**2]
  esmall = [(u, v) for (u, v, d) in subG.edges(data=True) if u != v and d["weight"] == np.e]

  # positions for all nodes - seed for reproducibility

  pos = nx.spring_layout(subG, k=0.40, iterations=20, seed = 12)  

  # add nodes to the graph
  nx.draw_networkx_nodes(subG, pos, node_size=800, node_color='olive', 
                         alpha = .5, label = 'Neighbors of input node')

  # draw the node of interest (input)
  nx.draw_networkx_nodes(subG, pos, node_size=800, nodelist = [chosen_node], 
                         node_color='crimson', label = 'Input node: {}'.format(chosen_node))

  # add edges to the graph
  nx.draw_networkx_edges(subG, pos, edgelist=elarge, width=3, alpha = 0.8, edge_color="steelblue", 
                         arrowsize=15, connectionstyle='arc3,rad=0.05')
  nx.draw_networkx_edges(subG, pos, edgelist=emedium, width=2.3, alpha=0.5, edge_color="skyblue",
                         arrowsize=15, connectionstyle='arc3,rad=-0.3')
  nx.draw_networkx_edges(subG, pos, edgelist=esmall, width=1.5, alpha=0.3, edge_color="slategray",
                         arrowsize=15, connectionstyle='arc3,rad=0.5')


  ax = plt.gca()
  ax.margins(0.03)
  plt.axis("off")
  plt.title('Network of the neighborhood of the input node {}'.format(chosen_node), fontsize = 22)
  box = dict(boxstyle='round', facecolor='snow', alpha=0.7, edgecolor="grey")
  plt.suptitle('Metric: {}\nValue: {}'.format(m_name, value_metric),x= .54,y = 0.56, fontsize = 18, bbox=box, horizontalalignment = 'left')
  plt.tight_layout()
  plt.legend(fontsize = 20, markerscale = .7)

  plt.show()

def choose_the_metric():

  ''' This fucntion allows to the user to choos the centrality metric that he want to observe 
  reguarding a node. '''

  metric_type = input('Choose a metric: \nA: Pagerank \nB: Betweeness \nC: Closeness Centrality\nD: Degree Centrality \n')
  if metric_type == 'A':
    choose_metric, metric = Metric.pagerank, 'Pagerank'
  elif metric_type == 'B':
    choose_metric, metric = Metric.betweness, 'Betweeness'
  elif metric_type == 'C':
    choose_metric, metric = Metric.closeness_cent, 'Closeness Centrality'
  elif metric_type == 'D':
    choose_metric, metric = Metric.degree_cent, 'Degree Centrality'

  return(choose_metric, metric)

def choose_interval_time():

  ''' This function allows the user to choose a time interval. 
  He can insert in input the staring time and the ending time of the interval. '''

  time_from = input('Choose a time interval:\nFrom: ')
  time_to = input('To: ')
  return([time_from, time_to])


def time_series(list_of_graphs, chosen_node, choose_metric): 

  ''' This function takes in input:
  1. list of graph: it is useful to create new graph at a given time interval
  2. chosen_node: a node which is chosen from the user
  3. choose_metric: a metric chosen from the user and which id computed for the node
  
  This function returns list of values that represent the values of the metric of the node, 
  computed in different time intervals. It also returns a list of dates that are the days 
  when the measure is computed. '''


  from_to = choose_interval_time()
  date_list = np.arange(from_to[0], from_to[1], dtype='datetime64[D]')
  date_list = ['{}/{}/{}'.format(d,m,y) for y, m, d in map(lambda x: str(x).split('-'), date_list)]
  interval_list = []
  for i in range(len(date_list)-1):
    interval_list.append([date_list[0], date_list[i+1]])
  metric_series = []
  for i in range(len(interval_list)):
    g_int = Graph()
    g_int.create_graph(list_of_graphs , interval_list[i])
    metric = Metric()
    metric_series.append(func2(g_int.my_graph, metric, chosen_node, choose_metric))
  return(metric_series,date_list)


def plot_time_series(metric_series, date_list, chosen_node, m):

  ''' This function returns a plot of the time series, computed by 'time_series' function. '''

  df_series = pd.DataFrame({"Date": date_list[:-1], "Metric": metric_series})
  plt.figure(figsize = (20,8))
  s = sns.lineplot(x = 'Date', y = 'Metric', data = df_series, color = 'mediumorchid',linewidth=4,  alpha = .7)
  s.set(ylim=(10, None))
  plt.title('Time Series of {} for the node {}'.format(m, chosen_node), fontsize = 20)
  plt.xticks(rotation=70)
  plt.show()

def visualization2(g, list_of_graphs):

  ''' This function get the chosen node and the chosen metric.
  It displays a network that let the user get a grasp of the importance of this input node
  with the chosen measure of centrality.
  Then it returns the time series that shows how the metric has been evolved over the chosen interval time. '''

  # Let the user choose the node
  chosen_node = int(input('Choose a node! \n'))
  choose_metric, m = choose_the_metric()

  metric = Metric()
  value_metric = func2(g, metric, chosen_node, choose_metric)
  plot_subgraph(g, chosen_node, m, value_metric)
  metric_series,date_list = time_series(list_of_graphs, chosen_node, choose_metric)
  return(metric_series, date_list, chosen_node, m)




#########################################################
#################### FUNCTIONALITY 3 ####################
#########################################################

def find_walk(walk: dict, start: int, end: int):
    u = end
    l = []
    while u != start:
        if u == -1:
            break
        parent = walk[u]
        l.append(parent)
        u = parent
    l.reverse()
    return l

def find_shortest_path(graph, start, end):
    l = []
    t1 = time()
    d, walk = dijkstra(graph, start)
    d = d[end]
    walk_dist = d
    x = find_walk(walk, start, end)
    if x != -1:
        l.append(x)
    else:
        return "Not Possible", []
    print("Node {} to {}, shortest distance: {}, time: {:.2f} secs".format(start, end, walk_dist, time() - t1))
    return walk_dist, l
def func3(graph: dict, pj, pn, p):
    l = []
    walk_dist = 0
    wd, li = find_shortest_path(graph, pj, p[0])
    walk_dist += wd
    l.extend(*li)
    for i in range(len(p) - 1):
        wd, li = find_shortest_path(graph, p[i], p[i+1])
        walk_dist += wd
        l.extend(*li)
    wd, li = find_shortest_path(graph, p[len(p)-1], pn)
    walk_dist += wd
    l.extend(*li)
    l.append(pn)
    return walk_dist, l





#########################################################
#################### VISUALIZATION 3 ####################
#########################################################

def choose_the_nodes():

  ''' This function allows to the user to choose some important nodes:
  1. the node from which the minimum path should start --> p1
  2. the node to which the minimum path should end --> pn
  3. a list od nodes through which the minimum path between p1 and p2 should pass --> p '''


  p1 = int(input('Choose the starting node:  '))
  pn = int(input('Choose the end node:  '))
  p = list(map(int, input("Choose the nodes to pass through:   ").strip().split()))

  return p1,pn,p

def create_my_subgraph_2(g, path):

  ''' This function is useful to collect a relatively small subgraoh for the visualization 
  of the minimun path from p1 and pn. 

  Given a path (a list of nodes that are in the minimum path),
  this function selects first level neighbors of each node in the path.
  So we get a larger list of nodes so that we can get a great subgraph'''


  # create a graph 
  myG = create_my_graph(g)

  # select the neighbors' nodes in the path

  subgraph_node = []
  for u in path:
    subgraph_node.append(u)
    neighbors = g[u]
    for node in neighbors:
      subgraph_node.append(node[0])

  subgraph_node = set(subgraph_node)

  # create the subgraph with networkx
  subG = myG.subgraph(subgraph_node) 
  return subG 

def plot_path(g, path, p1, pn, p):

  ''' This function take in input 
  - g: a graph
  - path: list of nodes that are in the minimum walk between p1 and pn
  - p1: the node from which the path starts
  - pn: the node to which the path ends
  - p: the list of nodes through which the path should pass
  This fucntion returns a plot with a 'big' network which contains the minimum path p1 --> pn
  and also the first level neighbors of the nodes in the path.
  The path is highlighted in yellow. '''


  # create the sub graph
  subG = create_my_subgraph_2(g, path)
  
  # classify the edges based on the weight that they have: 
  # small: 'Comment to answer'
  # medium: 'Comment to question'
  # large: 'Answer to question'

  elarge = [(u, v) for (u, v, d) in subG.edges(data=True) if u != v and d["weight"] == np.e**3]
  emedium = [(u, v) for (u, v, d) in subG.edges(data=True) if  u != v and d["weight"] == np.e**2]
  esmall = [(u, v) for (u, v, d) in subG.edges(data=True) if u != v and d["weight"] == np.e]


  # create a list of edges which are in the minimum path
  e_path = []
  for i in range(len(path)-1):
    print
    e_path.append((path[i],path[i+1]))

  # classify these edges based on the weight that they have in the graph 
  epath_large = []
  epath_medium = []
  epath_small = []
  for (u, v, d) in subG.edges(data=True):
    for e in e_path:
      if e == (u,v):
        if d["weight"] == np.e**3:
          epath_large.append((u,v))
        elif d["weight"] == np.e**2:
          epath_medium.append((u,v))
        elif d["weight"] == np.e:
          epath_small.append((u,v))

  plt.figure(figsize=(20,10))

  # positions for all nodes - seed for reproducibility

  pos = nx.spring_layout(subG, k=0.40, iterations=20, seed = 555)  

  # add nodes to the graph
  nx.draw_networkx_nodes(subG, pos, node_size=400, node_color='snow',alpha = .4, edgecolors = 'black')

  # draw nodes of path
  nx.draw_networkx_nodes(subG, pos, node_size=400, nodelist = path, alpha = 0.6,
                          node_color='cornflowerblue',label = 'Nodes of the shortest path from $p_1$ to $p_n$')

  nx.draw_networkx_nodes(subG, pos, node_size=600, nodelist = p, alpha = 0.8,
                          node_color='green', label = 'Nodes to must pass through  $p=$ {}'.format(p))

  nx.draw_networkx_nodes(subG, pos, node_size=800, nodelist = [p1], 
                          node_color='crimson', label = 'Start node   $p_1 = $ {}'.format(p1))

  nx.draw_networkx_nodes(subG, pos, node_size=800, nodelist = [pn], 
                          node_color='navy', label = 'End node    $p_n = ${}'.format(pn))


  # add edges to the graph
  nx.draw_networkx_edges(subG, pos, edgelist=elarge, width=5, alpha = 0.3, edge_color="grey", 
                          arrowsize=15, connectionstyle='arc3,rad=0.05')
  nx.draw_networkx_edges(subG, pos, edgelist=emedium, width=3.5, alpha=0.25, edge_color="darkgrey",
                          arrowsize=15, connectionstyle='arc3,rad=-0.3')
  nx.draw_networkx_edges(subG, pos, edgelist=esmall, width=2, alpha=0.2, edge_color="lightgray",
                          arrowsize=15, connectionstyle='arc3,rad=0.5')

  # add edges of the path
  nx.draw_networkx_edges(subG, pos, edgelist=epath_large, width=5, edge_color="gold", 
                          arrowsize=15, connectionstyle='arc3,rad=0.05')
  nx.draw_networkx_edges(subG, pos, edgelist=epath_medium, width=3.5, edge_color="gold",
                          arrowsize=15, connectionstyle='arc3,rad=-0.3')
  nx.draw_networkx_edges(subG, pos, edgelist=epath_small, width=2, edge_color="gold",
                          arrowsize=15, connectionstyle='arc3,rad=0.5')

  ax = plt.gca()
  ax.margins(0.03)
  plt.axis("off")
  plt.title('Shortest path from $p_1$ to $p_n$ that pass through $p$ (Overview plot)', fontsize = 22)
  plt.tight_layout()
  plt.legend(fontsize = 14, markerscale = .7)
  plt.show()



def detailed_plot_path(g, path, p1, pn, p, walk_dist):

  ''' This fucntion leads to a more clear and simple visualizaiton of the minimum path p1-->pn
  So that it containd only the nodes in the path.
  In the plot p1, pn and p are highlighted in different colors.'''


  # create the graph
  myG = create_my_graph(g)

  # create the subgraph
  subG = myG.subgraph(path) 

  # create the network 

  # create a list of edges which are in the minimum path
  e_path = []
  for i in range(len(path)-1):
    print
    e_path.append((path[i],path[i+1]))

  # define the edges
  epath_large = []
  epath_medium = []
  epath_small = []
  for (u, v, d) in subG.edges(data=True):
    for e in e_path:
      if e == (u,v):
        if d["weight"] == np.e**3:
          epath_large.append((u,v))
        elif d["weight"] == np.e**2:
          epath_medium.append((u,v))
        elif d["weight"] == np.e:
          epath_small.append((u,v))

  plt.figure(figsize=(20,7))

  # positions for all nodes - seed for reproducibility

  pos = nx.spring_layout(subG, k=0.40, iterations=20, seed = 14)  


  # draw nodes of path
  nx.draw_networkx_nodes(subG, pos, node_size=400, nodelist = path, alpha = 0.6,
                          node_color='cornflowerblue',label = 'Nodes of the shortest path from $p_1$ to $p_n$')

  nx.draw_networkx_nodes(subG, pos, node_size=600, nodelist = p, alpha = 0.8,
                          node_color='green', label = 'Nodes to must pass through  $p=$ {}'.format(p))

  nx.draw_networkx_nodes(subG, pos, node_size=800, nodelist = [p1], 
                          node_color='crimson', label = 'Start node  $p_1 = $ {}'.format(p1))

  nx.draw_networkx_nodes(subG, pos, node_size=800, nodelist = [pn], 
                          node_color='navy', label = 'End node    $p_n = ${}'.format(pn))
  nx.draw_networkx_labels(my_combined_subgraph, pos, labels=None, font_size=12, font_color='k', font_family='sans-serif', font_weight='normal', alpha=1.0)



  # draw edges of the path
  nx.draw_networkx_edges(subG, pos, edgelist=epath_large, width=5, edge_color="gold", 
                          arrowsize=15, connectionstyle='arc3,rad=0.05')
  nx.draw_networkx_edges(subG, pos, edgelist=epath_medium, width=3.5, edge_color="gold",
                          arrowsize=15, connectionstyle='arc3,rad=-0.3')
  nx.draw_networkx_edges(subG, pos, edgelist=epath_small, width=2, edge_color="gold",
                          arrowsize=15, connectionstyle='arc3,rad=0.5')

  ax = plt.gca()
  ax.margins(0.03)
  plt.axis("off")
  plt.title('A better representation of the path!', fontsize = 22)
  box = dict(boxstyle='round', facecolor='gold', alpha=0.4, edgecolor="gold")
  plt.suptitle('The walk distance between $p_1$ and $p_n$ is {}'.format(walk_dist),x= .5,y = 0.9, fontsize = 15, bbox=box)
  plt.tight_layout()
  plt.show()



def visualization3(g):

  # Let the user choose the start node, the end node and the nodes to must pass through 
  p1,pn,p = choose_the_nodes()

  # functionality 3 to get the path
  walk_dist, path = func3(g, p1, pn, p)

  # create the network
  plot_path(g, path, p1, pn, p)

  # create a detailed network
  detailed_plot_path(g, path, p1, pn, p, walk_dist)





#########################################################
#################### FUNCTIONALITY 4 ####################
#########################################################

def combine_graphs(graph1, graph2):
    d = copy.deepcopy(graph1)
    for k in graph2.keys():
        if k in d.keys():
            for i in range(len(graph2[k])):
                v, w = graph2[k][i]
                has_edge = False
                for j in range(len(d[k])):
                    if d[k][j][0] == v:
                        d[k][j][1] += w
                        has_edge = True
                if not has_edge:
                    d[k].append([v,w])
        else:
            d[k] = graph2[k]
    
    return d

def find_unique_nodes(graph1, graph2):
    u1s = []
    u2s = []
    for i in graph1.keys():
        if i not in graph2.keys() and len(graph1[i]) > 1:
            u1s.append(i)
    for i in graph2.keys():
        if i not in graph1.keys() and len(graph2[i]) > 1:
            u2s.append(i)
    return u1s, u2s


class MinCut:
    def __init__(self, graph):
        self.graph = copy.deepcopy(graph) 
        self.main_graph = copy.deepcopy(graph)

    def bfs(self, s, t, parent):
        visited = dict(zip(self.graph.keys(), [False] * len(self.graph.keys())))

        queue = []
        queue.append(s)
        visited[s] = True

        while queue:
            u = queue.pop(0)
            for ind, val in self.graph[u]:
                if ind in visited and visited[ind] == False and val > 0:
                    queue.append(ind)
                    visited[ind] = True
                    parent[ind] = u
        return True if visited[t] else False

    def dfs(self, graph, s, visited):
        visited[s] = True
        for i in graph.keys():
            flag = False
            for j in graph[s]:
                if j[0] == i and j[1] > 0:
                    flag = True
                    break
            if flag and not visited[i]:
                self.dfs(graph, i, visited)
    def minCut(self, source, sink):
        parent = dict(zip(self.graph.keys(), [-1] * len(self.graph.keys())))
        max_flow = 0

        while self.bfs(source, sink, parent):
            path_flow = float("Inf")
            s = sink
            while (s != source):
                for i in self.graph[parent[s]]:
                    if i[0] == s:
                        path_flow = min(path_flow, i[1])
                        break
                s = parent[s]
            max_flow += path_flow
            v = sink
            while (v != source):
                u = parent[v]
                for i in range(len(self.graph[u])):
                    if self.graph[u][i][0] == v:
                        self.graph[u][i][1] -= path_flow
                        break
                for i in range(len(self.graph[v])):
                    if self.graph[v][i][0] == u:
                        self.graph[v][i][1] += path_flow
                        break
                v = parent[v]

        visited = dict(zip(self.graph.keys(), [False] * len(self.graph.keys())))
        self.dfs(self.graph, s, visited)
        l = []
        for i in self.graph.keys():
            for j in self.graph[i]:
                for k in self.main_graph[i]:
                    if j[0] == k[0] and j[1] == 0 and k[1] > 0 and visited[i]:
                        l.append([i, j[0]])
        return l


def func4(graph, source, sink):
    mincut = MinCut(graph)
    my_mincut = mincut.minCut(source, sink)
    return my_mincut

#########################################################
#################### VISUALIZATION 4 ####################
#########################################################

def create_my_subgraph_3(g, path):

  ''' This function is useful to collect a suitable subgraph for the plot of the edges 
  that are in the min cut path. 
  It takes in input a grah g and a list of two nodes which had to be disconnected in the graph.
  In order to to select that list of nodes, we select the first and the second level
  nighbors of these two nodes. 
  Then the function creates a subgraph.'''

  # create a graph 
  myG = create_my_graph(g)

  # select the first and second level neighbors of nodes in the path
  subgraph_node = []
  for u in path:
    subgraph_node.append(u)
    neighbors1 = g[u]
    for node1 in neighbors1:
      subgraph_node.append(node1[0])
      neighbors2 = g[node1[0]]
      for node2 in neighbors2:
        subgraph_node.append(node2[0])

  subgraph_node = set(subgraph_node)

  # create the subgraph with networkx
  subG = myG.subgraph(subgraph_node) 
  return subG 

def plot_min_cut(combined_graph, u1, u2, mincut_edges):

  ''' This fucntion take in input:
  - combined_graph: a graph which is the result of the union of two graphs
  - u1, u2: two nodes that are unique in the respective graph
  - mincut_edges: a list of edges that makes the combined_graph disconnected into two
  networks (one that contains u1 and one that contains u2) 
  This function returns a plot which contains first and second level 'friends' of 
  u1 and u2 and the edges in the minimum cut are underlined in pink.
  '''

  my_combined_subgraph = create_my_subgraph_3(combined_graph, [u1,u2])
  
  # plot the graph
  plt.figure(figsize=(20,10))

  # select edges to avoid loops
  e = [(u, v) for (u, v, d) in my_combined_subgraph.edges(data=True) if u != v]


  # positions for all nodes - seed for reproducibility

  pos = nx.spring_layout(my_combined_subgraph, k=0.40, iterations=20, seed = 13)  

  # add nodes to the graph
  nx.draw_networkx_nodes(my_combined_subgraph, pos, node_size=400, node_color='thistle', 
                          alpha = .5)


  # draw the node of interest (input)
  nx.draw_networkx_nodes(my_combined_subgraph, pos, node_size=800, nodelist = [u1], 
                          node_color='royalblue', label = 'Node: {}'.format(u1))
  nx.draw_networkx_nodes(my_combined_subgraph, pos, node_size=800, nodelist = [u2], 
                          node_color='mediumseagreen', label = 'Node: {}'.format(u2))

  # add edges to the graph based on the weights
  widths = nx.get_edge_attributes(my_combined_subgraph, 'weight')

  nx.draw_networkx_edges(my_combined_subgraph, pos, edgelist=e, width=np.divide(list(widths.values()),5), 
                         alpha=0.25, edge_color="silver", arrowsize=20, connectionstyle='arc3,rad=-0.3', )

  nx.draw_networkx_edges(my_combined_subgraph, pos, edgelist=mincut_edges, width=np.divide(list(widths.values()),5), 
                         edge_color="deeppink", arrowsize=20, connectionstyle='arc3,rad=-0.3')
  
  ax = plt.gca()
  ax.margins(0.03)
  plt.axis("off")
  plt.title('Plot of the minimum path-cut for {}, {}'.format(u1,u2), fontsize = 22)
  box = dict(boxstyle='round', facecolor='deeppink', alpha=0.4, edgecolor="deeppink")
  plt.suptitle('Edges to be cut to disconnect node {} and node {}'.format(u1, u2),x= .5,y = 0.93, fontsize = 17, bbox=box)
  plt.tight_layout()
  plt.legend(fontsize = 15, markerscale = .4, title = 'Nodes to be \ndisconnected', title_fontsize=18 )

  plt.show()


def visualization4(list_of_graphs):

  # the user can choose the interval times in which the first and the second graph are computed

  interval1 = choose_interval_time()
  interval2 = choose_interval_time()
  print('\nThe first graph deals with the time interval from {} to {}'.format(interval1[0], interval1[1]))
  print('The second graph deals with the time interval from {} to {}\n'.format(interval2[0], interval2[1]))

  # create the two graphs with the respective time intervals
  g1 = Graph()
  g1.create_graph(list_of_graphs , interval1)
  g2 = Graph()
  g2.create_graph(list_of_graphs , interval2)

  # combine the two graphs with the suitable function of functionality 4
  combined_graph = combine_graphs(g1.my_graph, g2.my_graph) 

  # since not all the node in combine graph can be chosen to compute the min-cut
  # we select u1 and u2 at random among suitable nodes 
  u1s, u2s = find_unique_nodes(g1.my_graph, g2.my_graph)
  random.seed(20)
  u1 = random.choice(u1s)
  u2 = random.choice(u2s)
  # get a list of edges that consist of the min-cut for u1 and u2
  mincut_edges = func4(combined_graph, u1, u2)
  print('\nThe nodes to be disconnected are {} and {}.'.format(u1, u2))

  # plot the nerwork
  plot_min_cut(combined_graph, u1, u2, mincut_edges)
